```
dotnet run
```

状態を更新するのではなく新しく生成しているので、スタックに配置するために構造体の方が良いかもしれない。
IUserInterfaceの関数名が終わってる。

- 柔軟性を考えすぎると、コードは読みづらくなる。層ごとにコードを書いている人が違ってたくさんの人が書いているとかならあり。

- Domain層でゲームの状態と設定を定義して、Business層でそれら活用してゲームを管理する。

- Business層はPresentation層に依存しておらず、FactoryのInterfaceにのみ依存している。

- IUserInterfaceFactoryの実装がFactoryの実装（使い方）の説明になっているので、Business層側から簡単にFactroyを使うことができる。

- 新しいInterfaceが追加されるたびに、IUserInterfaceFactoryのenumを追加してFactoryでインスタンス作成を追加する（正直Factoryの実装はインスタンスを作っているだけで実装は簡単に把握できるのでInterfaceに分ける必要はなさそう。Interfaceを作るのは実装を把握する必要をなくすためなので、実装が簡単に把握できるFactoryとかはInterfaceにわける必要はなさそう。）

- こうすることで依存関係の逆転ができていて、Business層の実装を知らずにPresentation層に追加実装ができる（Presentation層側はInterfaceをoverrideするだけでいいし、Business側はInterfaceのメソッドを使っておけばいい。

- 右から左に向かって依存の流れができている（InterfaceとGameManagerはまとめて1つ考える）。

- ロジック側がUIを操作している感じだから、UI側で別スレッドで周り続けるようなrosとかunityとかsocketとかは扱いづらい。UIにロジックを動かすコールバック関数を渡すような設計じゃないとうまくかない。C++では改善されている。

※Business層はPresentation層からの入力は受け取って戻り値を返すことはできるが、Business層の好きなタイミングで出力することができない。1入力1出力しかできない。C++の方では改善されている。
![Qiita](class_mermaid.png "Qiita")

